# 编码问题

unicode utf-8 utf-16

参考资料:

[Unicode编码及其实现：UTF-16、UTF-8，and more](http://blog.csdn.net/thl789/article/details/7506133)

[Unicode和UTF-8、UTF-16、UTF-32](http://www.jianshu.com/p/35f5f7d07732)

***

## 小结

1. unicode 16bit OxD800 ~ OxDFFF 为辅助平面保留 ;
2. UTF-8 使用1~4个字节表示unicode 一个码元=8bit ;
3. UTF-16 使用 2 或者 4字节表示 unicode ,一个码元 = 16bit ;




## ASCII

8bit = 1字节

0-127 ASCII 码

128-255 扩展字符

+ 中文 GB2312:
	+ 只保留127之前的内容 用两个字节表示汉字
		+ 先高字节后低字节 
	+ 全角字符 : 127之后的希腊字母等都重新改编成两个字节
	+ ...
	+ 最后就决定 如果这个值 大于 127 则表示双字符集中的字符出现了


## Unicode

+ 为了统一 ISO 制定了 unicode
	+ 直接规定必须使用两个字节(16bit)统一表示所有字符.
	+ 原来的 unicode 编码不变,长度变成16bit ,只用到低8位,高8位永远是0.
	+ **字符** 和 **字节** : 
		+ "字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号


+ unicode 传输问题 --> UTF
	+ UTF-8 就是每次8bit 传输数据 UTF-16就是每次16bit


+  在Unicode字符集中的某个字符对应的代码值，称作代码点（Code Point），用16进制书写，并加上U+前缀。比如，‘田’的代码点是U+7530；‘A’的代码点是U+0041。
+  Unicode定义的字符集已经超过16位所能表达的范围，把所有这些CodePoint分成17个代码平面（Code Plane）：
U+0000 ~ U+FFFF划入基本多语言平面（Basic MultilingualPlane，简记为BMP）；
**即原始的16位**
其余划入16个辅助平面（Supplementary Plane），代码点范围U+10000 ~ U+10FFFF。虽然这样划分，但并不是每个Plane中的Code point都对应有字符，这里面有保留的，还有特殊用途的。


## UTF-8

> UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

### 编码规则

UTF-8 的编码规则很简单，只有二条：

1. 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2. 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。



### 举例:

严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。	
		
		
		
## UTF-16

+ unicode 用两个字节 16bit 表示字符
	+ 基本平面(BMP)就是 16bit 能表示的范围: U+ 0000 ~ U+FFFF
	+ 辅助平面 U+10000 ~ U+10FFFF
		+ 辅助平面内包含的字符个数是 (U+10FFFF-U+10000+1 = FFFFF+1 需要用 Math.pow(2,10) 来表示) UTF-16 用两个码元表示,则高位表示10bit 低位表示10bit.
+ UTF-16 一个码元就是 16bit 	
	+ 在 BMP 平面内 U+D800 ~ U+DFFF 这个范围是不映射的,UTF-16利用这个部分来表示辅助平面的内容
	+ 辅助平面内的 用两个码元来表示 32bit 称做代理对
		+ 代理对的高位是: CodePoint - U+10000 的前10bit + OxD800
		+ 代理对的低位是: 后10bit + OxDC00
		+ 之前提到过 OxD800 - OxDFFF 是保留位专门用于表示辅助平面 , 为了区分高低位,又特意拆成了两个部分: OxD800 ~ OxDBFF 和 OxDC00 ~ OxDFFF


	
		
		
	
